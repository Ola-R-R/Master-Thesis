---
output:
  pdf_document: default
  html_document: default
---

# Setup

```{r setup, include=F}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = TRUE, tidy = TRUE, fig.align = "center", tidy.opts = list(width.cutoff = 60))

# update.packages(ask = FALSE, checkBuilt = TRUE, Ncpus = 9L)

library(readxl)
library(tidyverse)
require(reshape2)
library(tseries)
library(astsa)
library(forecast)
library(viridis)
library(RQuantLib)
library(stringr)
library(xts)
library(MASS)
library(scales)
library(mvtnorm)
library(mnormt)
library(rugarch)
library(fGarch)
library(broom)
library(FactoMineR)
library(ggplot2)
library(gtable)
library(grid)
library(gridExtra)
library(YieldCurve)
library(bizdays)
library(Metrics)
library(future.apply)
library(foreach)
library(doParallel)
library(matrixStats)
library(parallel)  # For parallel processing
library(furrr)     # Alternative for parallel processing
library(writexl)
library(arrow)
library(data.table)
library(gginnards)
library(tibble)
library(magrittr)
library(splines)

options(future.globals.maxSize = 20000*1024^2)

plan(multisession, workers = detectCores() - 3) ## Run in parallel on local computer
```

# Importing Data

```{r}
zero_coupon_yields <- as.data.table(read_excel("Data/GOVT_ZEROCOUPON.xlsx"))
zero_coupon_dates <- as.Date(zero_coupon_yields$Dates)
zero_coupon_yields <- zero_coupon_yields %>% dplyr::select(-1)
zero_coupon_yields_periods <- c(1/2, 3/4, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
colnames(zero_coupon_yields) <- as.character(zero_coupon_yields_periods)
zero_coupon_yields <- as.matrix(zero_coupon_yields) / 100
write_parquet(as.data.frame(zero_coupon_yields), "Data/zero_coupon_yields.parquet")
write.table(zero_coupon_dates, "Data/zero_coupon_dates.txt", sep = ",", row.names = F, col.names = F)
```

# Extrapolating Data

```{r}
.factorBeta1 <- function(lambda, maturity) {
  (1 - exp(-lambda * maturity)) / (lambda * maturity)
}

.factorBeta2 <- function(lambda, maturity) {
  beta1 <- (1 - exp(-lambda * maturity)) / (lambda * maturity)
  beta1 - exp(-lambda * maturity)
}

.NS.estimator <- function(rate, maturity, lambda) {
  X <- cbind(1, .factorBeta1(lambda, maturity), .factorBeta2(lambda, maturity))
  betaPar <- setNames(coef(lm.fit(X, rate)), c("beta_0", "beta_1", "beta_2"))
  betaPar[is.na(betaPar)] <- 0  # Ensure no NA values
  list(Par = betaPar, Res = residuals(lm.fit(X, rate)))
}

Nelson.Siegel <- function(rate, maturity) {
  rate <- try.xts(rate, error = as.matrix)
  if (ncol(rate) == 1) rate <- matrix(as.vector(rate), 1, nrow(rate))

  lambdaValues <- maturity
  FinalResults <- matrix(0, nrow(rate), 4)
  colnames(FinalResults) <- c("beta_0", "beta_1", "beta_2", "lambda")

  lambdaOptimized <- vapply(lambdaValues, function(lambda) {
    optimize(.factorBeta2, interval = c(0.001, 1), maturity = lambda, maximum = TRUE)$maximum
  }, numeric(1))

  FinalResults <- future_sapply(1:nrow(rate), function(j) {
    InterResults <- vapply(seq_along(lambdaValues), function(i) {
      lambdaTemp <- lambdaOptimized[i]
      InterEstimation <- .NS.estimator(as.numeric(rate[j, ]), maturity, lambdaTemp)
      BetaCoef <- InterEstimation$Par
      SSR <- ifelse(BetaCoef[1] > 0 & BetaCoef[1] < 20, sum(InterEstimation$Res^2), 1e5)
      c(BetaCoef, lambdaTemp, SSR)
    }, numeric(5))

    BestRow <- which.min(InterResults[5, ])
    InterResults[1:4, BestRow]
  }, future.seed = TRUE)
  
  return(reclass(t(FinalResults), rate))
}

NSrates <- function(Coeff, maturity){
  Curve <- try.xts(matrix(0, nrow(Coeff), length(maturity)), error = as.matrix)
  colnames(Curve) <- make.names(maturity)
  Coeff <- as.matrix(Coeff)
  for (i in 1:nrow(Curve)) {
    Curve[i, ] <- as.numeric(Coeff[i, 1]) * rep(1, length(maturity)) + as.numeric(Coeff[i, 2]) * as.numeric(.factorBeta1(Coeff[i, 4], maturity)) + as.numeric(Coeff[i, 3]) * as.numeric(.factorBeta2(Coeff[i, 4], maturity))
  }
  return(Curve)
}
```

```{r}
extrapolate_fun <- function(forward_rates, frequency = 1/12, type = "Nelson Siegel") {
  # start_time <- Sys.time()
  
  tenors <- as.numeric(colnames(forward_rates))
  max_tenors <- tail(tenors, 1)
  
  tenors_extrapolated <- c(1/252, seq(frequency, ceiling(max_tenors), frequency))
  
  if (type == "Nelson Siegel") {
    ns_model <- Nelson.Siegel(forward_rates, tenors)
    forward_rates_extrapolated <- NSrates(ns_model, tenors_extrapolated)
  }
  
  forward_rates_extrapolated <- as.matrix(forward_rates_extrapolated)
  
  colnames(forward_rates_extrapolated) <- as.character(tenors_extrapolated)
  colnames(forward_rates_extrapolated)[1] <- "0"
  rownames(forward_rates_extrapolated) <- 1:nrow(forward_rates_extrapolated)
  
  # end_time <- Sys.time()
  # print(paste0("Total time taken: ", round(as.numeric(difftime(end_time, start_time, units = "secs")), 3), " seconds"))
  
  return(forward_rates_extrapolated)
}
```

```{r}
# zero_coupon_yields_extrapolated_1M <- extrapolate_fun(zero_coupon_yields, 1/12)
zero_coupon_yields_extrapolated_3M <- extrapolate_fun(zero_coupon_yields, 1/4)
# zero_coupon_yields_extrapolated_6M <- extrapolate_fun(zero_coupon_yields, 1/2)
# zero_coupon_yields_extrapolated_1Y <- extrapolate_fun(zero_coupon_yields, 1)

# write_parquet(as.data.frame(zero_coupon_yields_extrapolated_1M), "Data/zero_coupon_yields_extrapolated_1M.parquet")
write_parquet(as.data.frame(zero_coupon_yields_extrapolated_3M), "Data/zero_coupon_yields_extrapolated_3M.parquet")
# write_parquet(as.data.frame(zero_coupon_yields_extrapolated_6M), "Data/zero_coupon_yields_extrapolated_6M.parquet")
# write_parquet(as.data.frame(zero_coupon_yields_extrapolated_1Y), "Data/zero_coupon_yields_extrapolated_1Y.parquet")
```